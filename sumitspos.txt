totalprocess = 5
# Each process: [arrival_time, burst_time, priority, process_id]
proc = [] 

# Initialize process list with dummy values
for i in range(totalprocess):
    proc.append([0, 0, 0, 0])

# Function to calculate waiting time using FCFS logic on sorted processes
def get_wt_time(wt):
    service = [0] * totalprocess
    
    # Service time for the first process is its arrival time
    service[0] = proc[0][0] 
    wt[0] = 0

    for i in range(1, totalprocess):
        # Service time = previous service + previous burst time
        service[i] = service[i - 1] + proc[i - 1][1]
        
        # Waiting time = service time - arrival time
        # This formula is correct when service time is >= arrival time
        wt[i] = service[i] - proc[i][0]
        
        # Adjust for idle time: if service time < arrival time, waiting time is 0
        # The CPU was idle, and the process started at its arrival time.
        if wt[i] < 0:
            wt[i] = 0

# Function to calculate turnaround time
def get_tat_time(tat, wt):
    for i in range(totalprocess):
        # Turnaround Time = Burst Time + Waiting Time
        tat[i] = proc[i][1] + wt[i]

def findgc():
    wt = [0] * totalprocess
    tat = [0] * totalprocess
    wavg = 0
    tavg = 0

    # Calculate waiting and turnaround times
    get_wt_time(wt)
    get_tat_time(tat, wt)

    # Calculate Start Time and Completion Time
    stime = [0] * totalprocess
    ctime = [0] * totalprocess
    
    # For the first process (which is the first after sorting)
    stime[0] = proc[0][0] 
    ctime[0] = stime[0] + proc[0][1]

    for i in range(1, totalprocess):
        # Next start time = max(arrival time, previous completion time)
        # This correctly accounts for CPU idle time.
        stime[i] = max(proc[i][0], ctime[i - 1])
        ctime[i] = stime[i] + proc[i][1]

    # Print results
    print("Process_no\tArrival_time\tBurst_time\tPriority\tStart_time\tComplete_time\tTurn_Around_Time\tWaiting_Time")
    
    for i in range(totalprocess):
        wavg += wt[i]
        tavg += tat[i]
        print(f"{proc[i][3]}\t\t{proc[i][0]}\t\t{proc[i][1]}\t\t{proc[i][2]}\t\t{stime[i]}\t\t{ctime[i]}\t\t{tat[i]}\t\t\t{wt[i]}")

    print(f"\nAverage waiting time is : {wavg / totalprocess:.2f}")
    print(f"Average turnaround time : {tavg / totalprocess:.2f}")


if __name__ == "__main__":
    arrivaltime = [1, 2, 3, 4, 5]
    bursttime = [3, 5, 1, 7, 4]
    priority = [3, 4, 1, 7, 8]
    
    # Populate the process list
    for i in range(totalprocess):
        proc[i][0] = arrivaltime[i]
        proc[i][1] = bursttime[i]
        proc[i][2] = priority[i]
        proc[i][3] = i + 1  # process ID (P1, P2, P3, ...)

    # Sorting Logic: 
    # 1. Sort by Arrival Time (x[0])
    # 2. Tie-breaker: Sort by Priority (x[2]) - Lower priority number is executed first.
    proc.sort(key=lambda x: (x[0], x[2]))
    
    findgc()